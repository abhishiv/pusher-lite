// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, PusherChannel, PusherClient, WebSocket, _, crypto, packageInfo, request, uuid,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  WebSocket = require('websocket').client;

  uuid = require('node-uuid');

  crypto = require('crypto');

  EventEmitter = require("events").EventEmitter;

  request = require('request');

  _ = require('underscore');

  packageInfo = require('../package.json');

  PusherChannel = (function(superClass) {
    extend(PusherChannel, superClass);

    function PusherChannel(channel_name, channel_data) {
      this.channel_name = channel_name;
      this.channel_data = channel_data;
    }

    return PusherChannel;

  })(EventEmitter);

  PusherClient = (function(superClass) {
    extend(PusherClient, superClass);

    PusherClient.prototype.state = {
      name: "disconnected",
      socket_id: null
    };

    function PusherClient(credentials) {
      this.recieveMessage = bind(this.recieveMessage, this);
      this.connect = bind(this.connect, this);
      this.resetActivityCheck = bind(this.resetActivityCheck, this);
      this.getAuthtication = bind(this.getAuthtication, this);
      this.unsubscribe = bind(this.unsubscribe, this);
      this.subscribe = bind(this.subscribe, this);
      this.credentials = credentials;
    }

    PusherClient.prototype.subscribe = function(channel_name, channel_data) {
      var channel;
      if (channel_data == null) {
        channel_data = {};
      }
      this.getAuthtication(channel_name, channel_data, (function(_this) {
        return function(auth, channel_data) {
          var req;
          req = {
            id: uuid.v1(),
            event: "pusher:subscribe",
            data: {
              channel: channel_name,
              auth: auth,
              channel_data: JSON.stringify(channel_data)
            }
          };
          return _this.connection.sendUTF(JSON.stringify(req));
        };
      })(this));
      channel = this.channels[channel_name];
      if (channel) {
        new Error("Existing subscription to " + channel_name);
        return channel;
      } else {
        channel = new PusherChannel(channel_name, channel_data);
        this.channels[channel_name] = channel;
        return channel;
      }
    };

    PusherClient.prototype.unsubscribe = function(channel_name, channel_data) {
      var channel;
      if (channel_data == null) {
        channel_data = {};
      }
      console.log("unsubscribing from " + channel_name);
      this.getAuthtication(channel_name, channel_data, (function(_this) {
        return function(auth, channel_data) {
          var req;
          req = {
            id: uuid.v1(),
            event: "pusher:unsubscribe",
            data: {
              channel: channel_name,
              auth: auth,
              channel_data: JSON.stringify(channel_data)
            }
          };
          return _this.connection.sendUTF(JSON.stringify(req));
        };
      })(this));
      channel = this.channels[channel_name];
      if (channel) {
        delete this.channels[channel_name];
        return channel;
      } else {
        return new Error("No subscription to " + channel_name);
      }
    };

    PusherClient.prototype.getAuthtication = function(channel_name, channel_data, callback) {
      var form, requestOpts, socket_id, stringToSign;
      if (this.credentials.authEndpoint || this.credentials.auth) {
        socket_id = this.state.socket_id;
        form = _.extend({
          channel_name: channel_name,
          socket_id: socket_id
        }, channel_data);
        requestOpts = _.extend({
          method: 'POST',
          form: form,
          url: this.credentials.authEndpoint
        }, this.credentials.auth || {});
        request(requestOpts, (function(_this) {
          return function(err, res, body) {
            var data, e, error;
            if (res.statusCode === 200) {
              try {
                data = JSON.parse(body);
                channel_data = (function() {
                  try {
                    return JSON.parse(data.channel_data) || channel_data;
                  } catch (undefined) {}
                })();
              } catch (error) {
                e = error;
                console.error(e);
                return;
              }
              return callback(data.auth, channel_data);
            } else {
              return console.error(err || ("Error " + res.statusCode + " " + res.body));
            }
          };
        })(this));
        return;
      }
      if (this.credentials.secret) {
        stringToSign = this.state.socket_id + ":" + channel_name + ":" + (JSON.stringify(channel_data));
        callback(this.credentials.key + ':' + crypto.createHmac('sha256', this.credentials.secret).update(stringToSign).digest('hex'), channel_data);
        return;
      }
      throw new Error('secret or authEndpoint is required to subscribe channel');
    };

    PusherClient.prototype.resetActivityCheck = function() {
      if (this.activityTimeout) {
        clearTimeout(this.activityTimeout);
      }
      if (this.waitingTimeout) {
        clearTimeout(this.waitingTimeout);
      }
      return this.activityTimeout = setTimeout((function(_this) {
        return function() {
          console.log("pinging pusher to see if active at " + ((new Date).toLocaleTimeString()));
          _this.connection.sendUTF(JSON.stringify({
            event: "pusher:ping",
            id: uuid.v1(),
            data: {}
          }));
          return _this.waitingTimeout = setTimeout(function() {
            console.log("disconnecting because of inactivity at " + ((new Date).toLocaleTimeString()));
            _(_this.channels).each(function(channel) {
              return _this.unsubscribe(channel.channel_name, channel.channel_data);
            });
            console.log("connetcing again at " + ((new Date).toLocaleTimeString()));
            if (_this.connection.state !== "open") {
              return _this.connect();
            }
          }, 30000);
        };
      })(this), 120000);
    };

    PusherClient.prototype.connect = function() {
      var wsURL;
      this.client = new WebSocket();
      this.channels = {};
      this.client.on('connect', (function(_this) {
        return function(connection) {
          console.log('connected to pusher ');
          _this.connection = connection;
          console.log(_this.connection.state);
          _this.connection.on('message', function(msg) {
            _this.resetActivityCheck();
            return _this.recieveMessage(msg);
          });
          return _this.connection.on('close', function() {
            return _this.connect();
          });
        };
      })(this));
      wsURL = "wss://ws.pusherapp.com/app/" + this.credentials.key + "?client=" + packageInfo.name + "&version=" + packageInfo.version + "&protocol=7&flash=false";
      console.log("trying connecting to pusher on - " + wsURL);
      return this.client.connect(wsURL);
    };

    PusherClient.prototype.recieveMessage = function(msg) {
      var channel, data, payload;
      if (msg.type === 'utf8') {
        payload = JSON.parse(msg.utf8Data);
        if (payload.event === "pusher:connection_established") {
          data = JSON.parse(payload.data);
          this.state = {
            name: "connected",
            socket_id: data.socket_id
          };
          console.log(this.state);
          this.emit('connect');
        }
        if (payload.event === "pusher_internal:subscription_succeeded") {
          channel = this.channels[payload.channel];
          if (channel) {
            channel.emit('success');
          }
        }
        channel = this.channels[payload.channel];
        console.log("got event " + payload.event + " on " + ((new Date).toLocaleTimeString()));
        if (payload.event === "pusher:error") {
          console.log(payload);
        }
        if (channel) {
          return channel.emit(payload.event, JSON.parse(payload.data));
        }
      }
    };

    return PusherClient;

  })(EventEmitter);

  module.exports.PusherClient = PusherClient;

}).call(this);
