// Generated by CoffeeScript 1.7.0
(function() {
  var EventEmitter, PusherChannel, PusherClient, WebSocket, crypto, uuid, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  WebSocket = require('websocket').client;

  uuid = require('node-uuid');

  crypto = require('crypto');

  EventEmitter = require("events").EventEmitter;

  _ = require('underscore');

  PusherChannel = (function(_super) {
    __extends(PusherChannel, _super);

    function PusherChannel(channel_name, channel_data) {
      this.channel_name = channel_name;
      this.channel_data = channel_data;
    }

    return PusherChannel;

  })(EventEmitter);

  PusherClient = (function(_super) {
    __extends(PusherClient, _super);

    PusherClient.prototype.state = {
      name: "disconnected",
      socket_id: null
    };

    function PusherClient(credentials) {
      this.recieveMessage = __bind(this.recieveMessage, this);
      this.connect = __bind(this.connect, this);
      this.resetActivityCheck = __bind(this.resetActivityCheck, this);
      this.unsubscribe = __bind(this.unsubscribe, this);
      this.subscribe = __bind(this.subscribe, this);
      this.credentials = credentials;
    }

    PusherClient.prototype.subscribe = function(channel_name, channel_data) {
      var auth, channel, req, stringToSign;
      if (channel_data == null) {
        channel_data = {};
      }
      stringToSign = "" + this.state.socket_id + ":" + channel_name + ":" + (JSON.stringify(channel_data));
      auth = this.credentials.key + ':' + crypto.createHmac('sha256', this.credentials.secret).update(stringToSign).digest('hex');
      req = {
        id: uuid.v1(),
        event: "pusher:subscribe",
        data: {
          channel: channel_name,
          auth: auth,
          channel_data: JSON.stringify(channel_data)
        }
      };
      this.connection.sendUTF(JSON.stringify(req));
      channel = this.channels[channel_name];
      if (channel) {
        new Error("Existing subscription to " + channel_name);
        return channel;
      } else {
        channel = new PusherChannel(channel_name, channel_data);
        this.channels[channel_name] = channel;
        return channel;
      }
    };

    PusherClient.prototype.unsubscribe = function(channel_name, channel_data) {
      var auth, channel, req, stringToSign;
      if (channel_data == null) {
        channel_data = {};
      }
      stringToSign = "" + this.state.socket_id + ":" + channel_name + ":" + (JSON.stringify(channel_data));
      auth = this.credentials.key + ':' + crypto.createHmac('sha256', this.credentials.secret).update(stringToSign).digest('hex');
      req = {
        id: uuid.v1(),
        event: "pusher:unsubscribe",
        data: {
          channel: channel_name,
          auth: auth,
          channel_data: JSON.stringify(channel_data)
        }
      };
      this.connection.sendUTF(JSON.stringify(req));
      channel = this.channels[channel_name];
      if (channel) {
        delete this.channels[channel_name];
        return channel;
      } else {
        return new Error("No subscription to " + channel_name);
      }
    };

    PusherClient.prototype.resetActivityCheck = function() {
      if (this.activityTimeout) {
        clearTimeout(this.activityTimeout);
      }
      if (this.waitingTimeout) {
        clearTimeout(this.waitingTimeout);
      }
      return this.activityTimeout = setTimeout((function(_this) {
        return function() {
          _this.connection.sendUTF(JSON.stringify({
            event: "pusher:ping",
            id: uuid.v1(),
            data: {}
          }));
          return _this.waitingTimeout = setTimeout(function() {
            _(_this.channels).each(function(channel) {
              return _this.unsubscribe(channel.channel_name, channel.channel_data);
            });
            if (_this.connection.state !== "open") {
              return _this.connect();
            }
          }, 30000);
        };
      })(this), 120000);
    };

    PusherClient.prototype.connect = function() {
      this.client = new WebSocket();
      this.channels = {};
      this.client.on('connect', (function(_this) {
        return function(connection) {
          _this.connection = connection;
          _this.connection.on('message', function(msg) {
            _this.resetActivityCheck();
            return _this.recieveMessage(msg);
          });
          return _this.connection.on('close', function() {
            return _this.connect();
          });
        };
      })(this));
      return this.client.connect("wss://ws.pusherapp.com:443/app/" + this.credentials.key + "?client=node-pusher-server&version=0.0.1&protocol=5&flash=false");
    };

    PusherClient.prototype.recieveMessage = function(msg) {
      var channel, data, payload;
      if (msg.type === 'utf8') {
        payload = JSON.parse(msg.utf8Data);
        if (payload.event === "pusher:connection_established") {
          data = JSON.parse(payload.data);
          this.state = {
            name: "connected",
            socket_id: data.socket_id
          };
          this.emit('connect');
        }
        if (payload.event === "pusher_internal:subscription_succeeded") {
          channel = this.channels[payload.channel];
          if (channel) {
            channel.emit('success');
          }
        }
        channel = this.channels[payload.channel];
        if (channel) {
          return channel.emit(payload.event, JSON.parse(payload.data));
        }
      }
    };

    return PusherClient;

  })(EventEmitter);

  module.exports.PusherClient = PusherClient;

}).call(this);
